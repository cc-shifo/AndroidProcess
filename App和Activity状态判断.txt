Activity状态图
https://developer.android.google.cn/reference/android/app/Activity?hl=en
此链接下的Activity Lifcycle章节有描述。

1.判断activity是否在栈顶的。
1)原理获取当前运行的栈信息，从栈信息获取顶级Activity，再比较该Activity的包名是否与当前App相同。
代码如下：
private boolean getTopApp(Context mContext) {
		String lockAppName = "com.wong.ItemActivity";
		String topActivityName = "";
		ActivityManager am = (ActivityManager) mContext
				.getSystemService(Context.ACTIVITY_SERVICE);
		List<ActivityManager.RunningTaskInfo> runningTasks = am
				.getRunningTasks(1);
		if (runningTasks != null && !runningTasks.isEmpty()) {
			ActivityManager.RunningTaskInfo taskInfo = runningTasks.get(0);
			topActivityName = taskInfo.topActivity.getClassName();
		}
		if (lockAppName.equals(topActivityName)) {
			return true;
		}
		return false;
	}
2)原理2还是通过注册Application的ActivityLifecycleCallbacks回调，



2.App是否处于前台
利用ActivityLifecycleCallbacks如何判断APP是否在前台。通过判断start和stop里引用计数。stop引用计数等于0就是后台。
https://cloud.tencent.com/developer/article/1742114#:~:text=
%E5%88%A4%E6%96%AD%E5%89%8D%E5%8F%B0%20Activity%20%E6%98%AF%E5%90%A6%E5%B1%9E%E4%
BA%8E%E6%9C%AC%E8%BF%9B%E7%A8%8B%20%E7%BA%A6%E5%AE%9A%EF%BC%9A%E6%96%87%E4%B8%
AD%E8%A1%A8%E8%BF%B0%E8%AF%B4%E4%B8%80%E4%B8%AA,Activity%20%E5%A4%84%E4%BA%8E%E6%
BF%80%E6%B4%BB%E7%8A%B6%E6%80%81%E6%98%AF%E6%8C%87%E5%AE%83%E6%98%AF%E5%B1%8F%
E5%B9%95%E4%B8%8A%E5%BD%93%E5%89%8D%E5%B1%95%E7%A4%BA%E7%9A%84%20Activity%EF%BC%
8C%E4%B8%94%E6%B2%A1%E6%9C%89%E8%A2%AB%20Dialog%20%E8%A6%86%E7%9B%96%E3%80%82




3.内存回收
Android内存回收机制——Activity被系统回收了




4.被回收一定会执行onSaveInstanceState




5.onDestroy不一定都会执行
https://blog.csdn.net/yuzhidao/article/details/74638683?spm=1001.2
101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edef
ault%7ECTRLIST%7ERate-1-74638683-blog-107094901.pc_relevant_recovery_v2&depth_1-utm
_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-7463868
3-blog-107094901.pc_relevant_recovery_v2&utm_relevant_index=1
1）其实activity的生命周期，只有在正常的情况下，才会按顺序执行，如果发生其他状况，则另当别论。
正常点击返回键： onDestroy方法一定会执行；
从后台强杀分两种情况：
第一种：当前仅有一个activity，这时候，强杀，是会执行onDestroy方法的；
第二种：栈里面的第一个没有销毁的activity会执行ondestroy方法，其他的不会执行。

2）安卓后台杀死进程，Activity里 onDestroy会执行吗？
【答案】：OnDestroy会执行，也不会执行。
如果APP启动了MainActivity，MainActivity再启动了Activity1，Activity1再启动了Activity2。
这时在后台手动杀死进程（先显示进程列表，手指选中应用向上滑，杀死进程），会在log里看到
Activity1和Activity2的OnDestory没有执行，但MainActivity的onDestroy执行了。
所以一定要释放的资源请放在MainActivity的OnDestroy里。
备注：在安卓10（Q），安卓11， 安卓12上测试的，表现都一致
如果MainActivity 启动了Service了，经测试在不同手机表现不一致。
在OPPO手机测试，Service onDestroy没有执行。使用Google Pixel 2L手机测试，onDestroy执行了。
猜测国内手机因为厂商定制，Service onDestroy没有执行。
原文链接：https://blog.csdn.net/achirandliu/article/details/107094901




6.Android系统回收activity行为
https://www.jianshu.com/p/6d12ca933312
安卓本身不支持内存分页交换技术，是通过回收activity的方式来回收内存的。.activity处于
onPause或者onStop状态时，假如系统资源不足（内存不足），会被系统回收释放。
系统回收内存会存在两种行为：
1.当APP不在前台的时候，资源紧张，强杀APP进程并回收activity，这种情况不会调用生
命周期的onDestroy方法。可以用“开发者选项”中的“限制后台进程数”来模拟这种情况。

2.当APP在前台，系统资源不足的时候，会回收APP处于pause或stop状态的Activity，这种
情况不杀进程，但会调用onDestroy方法。可以用“开发者选项”中的“不保留活动”打开，来模拟这种情况。

因此，平时在onCreate方法里注册监听register，在onDestroy方法里反注册unregister不会有问题。
因为假如是情况1，进程被杀掉了，不执行onDestroy方法也没事，进程都没了，就无所谓内存泄
露的事。假如是情况2，那么会执行onDestroy方法反注册。

一下链接证明了此说法（看截图）
https://blog.csdn.net/u013718730/article/details/102028503
